import sqlite3
import telebot
import logging
# import sqlite3 # Якщо хочете зберігати дані в базу даних SQLite

# --- 1. Ваш токен бота ---
TOKEN = '8039977178:AAGS-GbH-lhljGGG6OgJ2iMU_ncB-JzeOvU' # <--- ВСТАВТЕ СЮДИ ВАШ РЕАЛЬНИЙ ТОКЕН

# --- 2. ID адміністратора ---
# Знайдіть свій chat_id через @userinfobot у Telegram і вставте його сюди.
# Це потрібно для сповіщень адміністратору про нові товари.
ADMIN_CHAT_ID = 8184456641 # <--- ЗАМІНІТЬ НА ВАШ РЕАЛЬНИЙ CHAT_ID АДМІНА (ЦЕ ЦИФРИ)
# Наприклад: ADMIN_CHAT_ID = 123456789

# --- 3. ID каналу для публікацій ---
# Якщо ви хочете автоматично публікувати товари в канал.
# Знайдіть ID каналу (наприклад, через @get_id_bot, або переславши повідомлення з каналу боту)
# ID каналу починається з '-100'
CHANNEL_ID = -1002535586055 # <--- ЗАМІНІТЬ НА РЕАЛЬНИЙ ID КАНАЛУ (НАПРИКЛАД: -1001234567890)
# Переконайтеся, що ваш бот є адміністратором каналу з правом публікувати повідомлення.


# --- 4. Ініціалізація бота ---
bot = telebot.TeleBot(TOKEN)

# --- 5. Налаштування логування ---
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    handlers=[
                        logging.FileHandler("bot.log"), # Записувати логи у файл
                        logging.StreamHandler()        # Виводити логи в консоль
                    ])
logger = logging.getLogger(__name__)

# --- 6. Змінна для зберігання стану користувачів ---
user_data = {} # chat_id: {'step': 'current_step', 'product_name': '', 'price': '', 'description': '', 'photos': []}

# --- 7. Обробник команди /start ---
@bot.message_handler(commands=['start'])
def send_welcome(message):
    chat_id = message.chat.id
    username = message.from_user.first_name if message.from_user.first_name else "друже"
    
    welcome_text = (
        f"Привіт, {username}! 👋 Я твій **Sellerbot**. \n"
        f"Я допоможу тобі легко продавати та купувати товари у нашому ком'юніті. \n\n"
        f"✅ Щоб **продати товар**, використай команду /sell\n"
        f"➡️ Щоб дізнатися **правила та комісію**, використай /rules\n"
        f"💰 Переглянути **доступні товари** можна тут: [Наш канал]({CHANNEL_ID if str(CHANNEL_ID).startswith('-100') else 'https://t.me/your_channel_link_here'}) \n\n" # Замініть на реальне посилання
        f"Зверни увагу: наш бот не зберігає особисті дані, окрім тих, що ти сам надаєш для оголошень."
    )
    bot.send_message(chat_id, welcome_text, parse_mode='Markdown', disable_web_page_preview=True)
    logger.info(f"Команда /start від {chat_id} ({username})")

# --- 8. Обробник команди /rules ---
@bot.message_handler(commands=['rules'])
def send_rules(message):
    chat_id = message.chat.id
    rules_text = (
        f"📜 **Правила та умови продажу:** 📜\n\n"
        f"1.  **Комісія:** Ми беремо **10% комісії** від вартості кожного проданого товару. Комісія сплачується продавцем після успішного завершення угоди.\n"
        f"    * **Спосіб оплати:** Комісію можна перерахувати на **Monobank** (номер карти буде надано після продажу) або **криптовалютою** (адреса гаманця буде надана).\n"
        f"    * **Термін оплати:** Протягом 24 годин після повідомлення про продаж.\n"
        f"    * **Наслідки несплати:** Несплата комісії призводить до блокування вашого акаунту для подальших продажів.\n\n"
        f"2.  **Порядок розміщення:** Ваше оголошення повинно містити:\n"
        f"    * **Якісне фото:** Чітке зображення товару (можна кілька).\n"
        f"    * **Назва товару:** Коротко та зрозуміло.\n"
        f"    * **Детальний опис:** Стан, особливості, комплект, причини продажу тощо.\n"
        f"    * **Ціна:** Обов'язково вказати валюту (наприклад, 1000 UAH або 30$).\n"
        f"    * **Місце знаходження:** Місто або можливість доставки.\n"
        f"    * *(За бажанням) Контакт продавця: Зазвичай це ваш Telegram-нік, який бот додасть автоматично.*\n\n"
        f"3.  **Модерація:** Всі оголошення проходять модерацію адміністратором. Ми залишаємо за собою право відмовити в публікації без пояснення причин, якщо оголошення не відповідає правилам або тематиці каналу.\n\n"
        f"4.  **Відповідальність:** Ми є лише платформою для розміщення оголошень. Вся відповідальність за якість товару, відповідність опису та безпеку угоди лежить на продавці та покупці.\n\n"
        f"Дякуємо за розуміння та бажаємо успішних продажів!"
    )
    bot.send_message(chat_id, rules_text, parse_mode='Markdown')
    logger.info(f"Команда /rules від {chat_id}")

# --- 9. Обробник команди /sell ---
@bot.message_handler(commands=['sell'])
def handle_sell_command(message):
    chat_id = message.chat.id
    logger.info(f"Команда /sell від {chat_id}")

    # Перевіряємо, чи користувач вже проходить процес продажу
    if chat_id in user_data:
        bot.send_message(chat_id, "Ви вже розпочали процес додавання товару. Будь ласка, завершіть його або скористайтеся /cancel для відміни.")
        return

    # Ініціалізуємо дані для цього користувача і встановлюємо перший крок
    user_data[chat_id] = {'step': 'waiting_for_product_name', 'photos': []}
    bot.send_message(chat_id,
                     "Добре, почнімо процес продажу. \n"
                     "Будь ласка, **напишіть назву товару**, який ви хочете продати.")

# --- 10. Обробник для відміни процесу ---
@bot.message_handler(commands=['cancel'])
def handle_cancel_command(message):
    chat_id = message.chat.id
    if chat_id in user_data:
        del user_data[chat_id]
        bot.send_message(chat_id, "Процес додавання товару скасовано. Можете почати заново, якщо бажаєте.")
        logger.info(f"Користувач {chat_id} відмінив процес.")
    else:
        bot.send_message(chat_id, "Ви не перебуваєте в процесі додавання товару.")

# --- 11. Обробник для отримання назви товару ---
@bot.message_handler(func=lambda message: message.chat.id in user_data and \
                                         user_data[message.chat.id]['step'] == 'waiting_for_product_name')
def handle_product_name(message):
    chat_id = message.chat.id
    product_name = message.text.strip()

    if not product_name:
        bot.send_message(chat_id, "Назва товару не може бути порожньою. Будь ласка, введіть назву.")
        return

    user_data[chat_id]['product_name'] = product_name
    user_data[chat_id]['step'] = 'waiting_for_price'

    logger.info(f"Користувач {chat_id} ввів назву товару: {product_name}")
    bot.send_message(chat_id,
                     f"Чудово! Ви продаєте **{product_name}**. \n"
                     f"Тепер **введіть бажану ціну** (наприклад, `100 UAH`, `50$`, `ціна договірна`).")

# --- 12. Обробник для отримання ціни товару ---
@bot.message_handler(func=lambda message: message.chat.id in user_data and \
                                         user_data[message.chat.id]['step'] == 'waiting_for_price')
def handle_price(message):
    chat_id = message.chat.id
    price = message.text.strip()

    if not price:
        bot.send_message(chat_id, "Ціна товару не може бути порожньою. Будь ласка, введіть ціну.")
        return

    user_data[chat_id]['price'] = price
    user_data[chat_id]['step'] = 'waiting_for_description'

    logger.info(f"Користувач {chat_id} ввів ціну: {price}")
    bot.send_message(chat_id,
                     f"Ціна **{price}** прийнята. \n"
                     f"Тепер **опишіть ваш товар детальніше** (стан, особливості, комплект, тощо).")

# --- 13. Обробник для отримання опису товару ---
@bot.message_handler(func=lambda message: message.chat.id in user_data and \
                                         user_data[message.chat.id]['step'] == 'waiting_for_description')
def handle_description(message):
    chat_id = message.chat.id
    description = message.text.strip()

    if not description:
        bot.send_message(chat_id, "Опис товару не може бути порожнім. Будь ласка, введіть опис.")
        return

    user_data[chat_id]['description'] = description
    user_data[chat_id]['step'] = 'waiting_for_photos'

    logger.info(f"Користувач {chat_id} ввів опис.")
    bot.send_message(chat_id,
                     f"Опис додано. Тепер, будь ласка, **надішліть фотографії** вашого товару (можна кілька). "
                     f"Коли закінчите, просто надішліть будь-яке текстове повідомлення або команду, наприклад `/done`.")

# --- 14. Обробник для отримання фотографій ---
# Цей обробник спрацює для будь-якого повідомлення, що містить фото,
# якщо користувач на кроці 'waiting_for_photos'
@bot.message_handler(content_types=['photo'],
                     func=lambda message: message.chat.id in user_data and \
                                          user_data[message.chat.id]['step'] == 'waiting_for_photos')
def handle_photos(message):
    chat_id = message.chat.id
    if len(user_data[chat_id]['photos']) >= 10: # Обмеження на кількість фото
        bot.send_message(chat_id, "Ви вже надіслали максимальну кількість фотографій (10).")
        return

    # Зберігаємо file_id найбільшої версії фото
    photo_file_id = message.photo[-1].file_id
    user_data[chat_id]['photos'].append(photo_file_id)
    logger.info(f"Користувач {chat_id} надіслав фото: {photo_file_id}")
    bot.send_message(chat_id, f"Фото прийнято! Надішліть ще або надішліть будь-яке текстове повідомлення (наприклад, `/done`), щоб завершити.")

# --- 15. Обробник для завершення введення фото або інших текстових повідомлень ---
@bot.message_handler(func=lambda message: message.chat.id in user_data and \
                                         user_data[message.chat.id]['step'] == 'waiting_for_photos' and \
                                         message.text not in ['/sell', '/start', '/rules', '/cancel'])
def finish_photos_and_send_to_admin(message):
    chat_id = message.chat.id
    
    # Перевіряємо, чи є хоча б одна фотографія, якщо не було надіслано '/done'
    if not user_data[chat_id]['photos']:
        bot.send_message(chat_id, "Будь ласка, надішліть хоча б одну фотографію товару, або відмініть процес /cancel.")
        return

    # Збираємо всю інформацію про товар
    product_name = user_data[chat_id]['product_name']
    price = user_data[chat_id]['price']
    description = user_data[chat_id]['description']
    photos_ids = user_data[chat_id]['photos']
    
    # Формуємо повідомлення для користувача
    final_user_message = (
        f"✅ **Ваше оголошення успішно надіслано!** ✅\n\n"
        f"Ми отримали вашу інформацію. Ось що ми отримали:\n"
        f"**Назва:** {product_name}\n"
        f"**Ціна:** {price}\n"
        f"**Опис:** {description}\n"
        f"**Фото:** ({len(photos_ids)} шт.)\n\n"
        f"Адміністратор перевірить ваше оголошення, і ми скоро опублікуємо його у каналі."
        f"Дякуємо за використання Sellerbot! 😊"
    )
    bot.send_message(chat_id, final_user_message, parse_mode='Markdown')
    logger.info(f"Користувач {chat_id} завершив введення товару: {product_name}. Відправлення адміністратору.")

    # --- ЛОГІКА ВІДПРАВКИ АДМІНІСТРАТОРУ ТА ПУБЛІКАЦІЇ ---

    # Створюємо MediaGroup для відправки фотографій разом з текстом
    media = []
    if photos_ids:
        for i, photo_id in enumerate(photos_ids):
            if i == 0: # Додаємо підпис до першого фото
                caption_text = (
                    f"🔔 **НОВЕ ОГОЛОШЕННЯ НА МОДЕРАЦІЮ!** 🔔\n\n"
                    f"**Від користувача:** @{message.from_user.username if message.from_user.username else 'ID:' + str(chat_id)}\n"
                    f"**Контакт:** [Посилання на чат з користувачем](tg://user?id={chat_id})\n\n"
                    f"**Назва:** {product_name}\n"
                    f"**Ціна:** {price}\n"
                    f"**Опис:** {description}\n\n"
                    f"**Дії:** \n"
                    f"/approve_{chat_id}_{len(user_data[chat_id]['photos'])} #id_{chat_id} (опублікувати)\n" # Тут потрібна складна логіка для approve
                    f"/reject_{chat_id} (відхилити)"
                )
                media.append(telebot.types.InputMediaPhoto(photo_id, caption=caption_text, parse_mode='Markdown'))
            else:
                media.append(telebot.types.InputMediaPhoto(photo_id))
    
    # Відправка сповіщення адміністратору
    if str(ADMIN_CHAT_ID).isdigit(): # Перевірка, що ADMIN_CHAT_ID є числом (не заглушкою)
        try:
            if media:
                bot.send_media_group(ADMIN_CHAT_ID, media)
            else: # Якщо фотографій немає, просто відправляємо текст
                admin_notification_text = (
                    f"🔔 **НОВЕ ОГОЛОШЕННЯ НА МОДЕРАЦІЮ!** 🔔\n\n"
                    f"**Від користувача:** @{message.from_user.username if message.from_user.username else 'ID:' + str(chat_id)}\n"
                    f"**Контакт:** [Посилання на чат з користувачем](tg://user?id={chat_id})\n\n"
                    f"**Назва:** {product_name}\n"
                    f"**Ціна:** {price}\n"
                    f"**Опис:** {description}\n\n"
                    f"**Дії:** \n"
                    f"/approve_{chat_id} #id_{chat_id} (опублікувати)\n"
                    f"/reject_{chat_id} (відхилити)"
                )
                bot.send_message(ADMIN_CHAT_ID, admin_notification_text, parse_mode='Markdown')
            
            logger.info(f"Сповіщення про новий товар відправлено адміністратору {ADMIN_CHAT_ID}")
            
            # TODO: Зберегти дані оголошення в базу даних тут.
            # Наприклад:
            # save_to_db(chat_id, product_name, price, description, photos_ids)
            # Приклад функції збереження в SQLite:
            # def save_to_db(user_id, name, price, desc, photos):
            #     conn = sqlite3.connect('products.db')
            #     cursor = conn.cursor()
            #     cursor.execute('''
            #         CREATE TABLE IF NOT EXISTS products (
            #             id INTEGER PRIMARY KEY AUTOINCREMENT,
            #             user_id INTEGER,
            #             name TEXT,
            #             price TEXT,
            #             description TEXT,
            #             photos TEXT, # Зберігати як JSON рядок або розділені коми
            #             status TEXT DEFAULT 'pending'
            #         )
            #     ''')
            #     cursor.execute("INSERT INTO products (user_id, name, price, description, photos) VALUES (?, ?, ?, ?, ?)",
            #                    (user_id, name, price, desc, ",".join(photos)))
            #     conn.commit()
            #     conn.close()

        except Exception as e:
            logger.error(f"Не вдалося відправити сповіщення адміністратору {ADMIN_CHAT_ID}: {e}")
            bot.send_message(chat_id, "Виникла помилка при відправці адміністратору. Будь ласка, спробуйте пізніше або зв'яжіться з підтримкою.")
    else:
        logger.warning("ADMIN_CHAT_ID не встановлено або не є числом. Сповіщення адміністратору не відправлено.")
        bot.send_message(chat_id, "Налаштування адміністратора не завершено. Ваш товар не буде надіслано адміністратору для модерації.")


    # Очищаємо стан користувача після завершення процесу
    del user_data[chat_id]

# --- 16. Запуск бота ---
logger.info("Бот запущено. Початок polling...")
try:
    bot.polling(none_stop=True, interval=0) # none_stop=True дозволяє боту не зупинятися при помилках
except Exception as e:
    logger.critical(f"Сталася критична помилка при запуску polling: {e}")